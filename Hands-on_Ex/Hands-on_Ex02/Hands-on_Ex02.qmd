---
title: "Hands-on Exercise 2"
author: "Gautamgovan"
date: "Sep 4, 2025"
date-modified: "last-modified"
format: 
  html:
    toc: true
    number-sections: true
execute: 
  echo: true
  eval: true
  warning: false
  freeze: true 
---

## Overview {.unnumbered}

**Spatial Point Pattern Analysis (SPPA)** is the evaluation of the pattern or distribution of a set of points on a surface. The points may represent:

-   Events such as crimes, traffic accidents, or disease onsets, or\
-   Business services (e.g., coffee shops and fast-food outlets) or facilities such as childcare centres and eldercare centres.

First-order Spatial Point Pattern Analysis (1st-SPPA) focuses on understanding the intensity or density of points across a study area. It examines how the distribution of points varies over space, essentially identifying trends or patterns in point density. This type of analysis deals with the individual locations of points and their distribution, without considering interactions between them.

Second-order spatial point pattern analysis examines the relationships between points, studying whether they are clustered, dispersed, or randomly distributed using tools like Ripley’s K function or nearest-neighbor analysis. It answers the question: “How do points interact with each other in space?”

## First Order Spatial Point Pattern Analysis

In essence, 1st-SPPA helps answer questions such as:

-   Where are points most densely located within the study area?\
-   Is point density uniform, or does it vary across space?\
-   How spread out is the point pattern?

In this chapter, we will gain hands-on experience with [spatstat](https://spatstat.org/) to perform two commonly used 1st-SPPA methods.

The specific questions we would like to answer are as follows:

-   Are the childcare centres in Singapore randomly distributed throughout the country?\
-   If the answer is not, then the next logical question is: where are the locations with higher concentration of childcare centres?

### The Data

Child Care Services data from data.gov.sg, a point feature data providing both location and attribute information of childcare centres. Master Plan 2019 Subzone Boundary (No Sea), a polygon feature data providing information of URA 2019 Master Plan Planning Subzone boundary data.

geojson format were used

### Installing and Loading the R packages

In this hands-on exercise, we will use five R packages:

-   **sf**: A modern package designed to import, manage, and process vector-based geospatial data in R.\
-   **spatstat**: A powerful package for point pattern analysis. We will use it to perform 1st- and 2nd-order spatial point pattern analysis and derive kernel density estimation (KDE) layers.\
-   **terra**: A fast and efficient package for working with raster and vector data, designed to replace the older raster package. In our exercise, we will use it to convert image outputs generated by `spatstat` into terra format.\
-   **tmap**: A package for creating cartographic-quality static maps and interactive maps (via the leaflet API).\
-   **rvest**: A package for web scraping, which we can use to harvest data directly from web pages.

We will install and load these packages using the following code:

```{r}
pacman::p_load(sf, terra, spatstat, 
               tmap, rvest, tidyverse)
```

### Importing and Wrangling Geospatial Data Sets

```{r}
subzone_path   <- "data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaGEOJSON.geojson"
childcare_path <- "data/geospatial/ChildCareServices.geojson"
```

```{r}
# Read datasets
mpsz_sf      <- st_read(subzone_path, quiet = TRUE)
childcare_sf <- st_read(childcare_path, quiet = TRUE)

# Quick checks
print(st_geometry_type(mpsz_sf)[1])
print(st_geometry_type(childcare_sf)[1])
```

```{r}
#Validate geometry
mpsz_sf      <- st_make_valid(mpsz_sf)
childcare_sf <- st_make_valid(childcare_sf)
```

```{r}
#Transform both datasets to Singapore SVY21 CRS (EPSG:3414)
target_epsg <- 3414

mpsz_sf      <- st_transform(mpsz_sf, target_epsg)
childcare_sf <- st_transform(childcare_sf, target_epsg)
```

```{r}
#Confirm both are aligned
st_crs(mpsz_sf)$epsg
st_crs(childcare_sf)$epsg

identical(st_crs(mpsz_sf), st_crs(childcare_sf))
# Should return TRUE
```

```{r}
#Optional tidying (only if these fields exist in subzone data)
if (all(c("SUBZONE_N","PLN_AREA_N") %in% names(mpsz_sf))) {
  mpsz_sf <- mpsz_sf |>
    filter(SUBZONE_N != "SOUTHERN GROUP",
           PLN_AREA_N != "WESTERN ISLANDS",
           PLN_AREA_N != "NORTH-EASTERN ISLANDS")
}
```

#### Mapping the geo spatial data sets

```{r}
#Quick visual check
tmap_mode("plot")
tm_shape(mpsz_sf) + tm_polygons(alpha = 0.2) +
tm_shape(childcare_sf) + tm_dots(size = 0.03, col = "red")
```

Interactive point symbol map

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

### Geospatial Data Wrangling

spatstat relies on its own specific data structures like ppp (planar point pattern) for point data and owin for observation windows. In this section, we will learn how to convert sf (Simple Features) objects into spatstat ppp and owin object.

#### Converting sf data frames to ppp class

The **spatstat** package requires point event data in **ppp** object form.\
We can use the \[`as.ppp()`\] function from **spatstat** to convert `childcare_sf` into **ppp** format. class() of Base R will be used to verify the object class of childcare_ppp.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
class(childcare_ppp)
```

Summary statistics

```{r}
summary(childcare_ppp)
```

#### Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region. The code chunk below, as.owin() of spatstat is used to covert mpsz_sf into owin object of spatstat.

```{r}
sg_owin <- as.owin(mpsz_sf)
class(sg_owin)
plot(sg_owin)
```

#### Combining point events object and owin object

In this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code chunk below.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r}
childcareSG_ppp
```

### Clark-Evan Test for Nearest Neighbour Analysis

Nearest Neighbor Analysis (NNA) is a spatial statistics method that calculates the average distance between each point and its closest neighbor to determine if a pattern of points is clustered, dispersed, or randomly distributed.

Clark-Evans test is a specific statistical method used within NNA to quantify whether a point pattern is clustered, random, or uniformly spaced, using the Clark-Evans aggregation index (R) to describe this pattern. NNA provides a numerical value that describes the degree of clustering or regularity, and the Clark-Evans test calculates a specific index (R) for this purpose

In this section, we will perform the **Clark-Evans test** of aggregation for a spatial point pattern by using \[`clarkevans.test()`\] from the **spatstat.explore** package.

The test hypotheses are:

-   **H₀**: The distribution of childcare services is randomly distributed.\
-   **H₁**: The distribution of childcare services is not randomly distributed.

We will use a **95% confidence interval** for this test.

#### Perform the Clark-Evans test without CSR

clarkevans.test() of spatstat.explore package support two Clark-Evans test, namely: without CRS and with CRS. In the code chunk below, Clark-Evans test without CSR method is used.

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
```

Statistical Conclusion:

From the Clark-Evans test, the observed R value is **0.53532** with a **p-value \< 2.2e-16**.\
Since the p-value is far below 0.05, we reject the null hypothesis of complete spatial randomness.\
The result supports the alternative hypothesis that childcare services are **clustered** rather than randomly distributed.

Business Communication:

Based on this analysis, we conclude that childcare centres in Singapore tend to be located in clusters.\
This clustering likely reflects demand-driven planning (e.g., centres opening in areas with higher child populations) or zoning policies.\
For decision-makers, this indicates that underserved areas may exist where childcare services are sparse, highlighting opportunities for **policy adjustments or business expansion** into less-served neighborhoods.

### Kernel Density Estimation Method

Kernel Density Estimation (KDE) is a valuable tool for visualising and analyzing first-order spatial point patterns. It is widely considered a method within Exploratory Spatial Data Analysis (ESDA) because it’s used to visualize and understand spatial data patterns by transforms discrete point data (like locations of childcare service, crime incidents or disease cases) into continuous density surfaces that reveal clusters and variations in event occurrences, without making prior assumptions about data distribution. It helps to begin understanding data distribution, identify hotspots, and explore relationships between spatial variables before performing more rigorous analysis.

In this section, you will learn how to compute the kernel density estimation (KDE) of childcare services in Singapore.

#### Working with automatic bandwidth selection method

The code chunk below computes a kernel density by using the following configurations of \[`density()`\] from **spatstat**:

-   **`bw.diggle()`**: automatic bandwidth selection method.\
    Other recommended methods are \[`bw.CvL()`\], \[`bw.scott()`\], or \[`bw.ppl()`\].\
-   The smoothing kernel used is **gaussian** (default).\
    Other smoothing methods include: `"epanechnikov"`, `"quartic"`, or `"disc"`.\
-   The intensity estimate can be corrected for **edge effect bias** using the method described by Jones (1993) and Diggle (2010, equation 18.9).\
    The default is **FALSE**.

```{r}
kde_SG_diggle <- density(
  childcareSG_ppp,
  sigma=bw.diggle,
  edge=TRUE,
  kernel="gaussian") 
plot(kde_SG_diggle)
#summary(kde_SG_diggle)
```

```{r}
summary(kde_SG_diggle)
```

```{r}

bw <- bw.diggle(childcareSG_ppp)
bw
```

#### Rescalling KDE values

In the code chunk below, rescale.ppp() is used to covert the unit of measurement from meter to kilometer.

```{r}
childcareSG_ppp_km <- rescale.ppp(
  childcareSG_ppp, 1000, "km")
```

Now, we can re-run density() using the resale data set and plot the output kde map.

```{r}
kde_childcareSG_km <- density(childcareSG_ppp_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
plot(kde_childcareSG_km)
```

#### Working with different kernel methods

By default, the kernel method used in density.ppp() is gaussian. But there are three other options, namely: Epanechnikov, Quartic and Dics.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel function.

```{r}
# Arrange in 2x2 grid with larger maps
par(mfrow = c(2, 2), mar = c(2, 2, 3, 2))  # adjust margins

# Gaussian
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "gaussian"),
     main = "")
title("Gaussian", line = 1)

# Epanechnikov
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "epanechnikov"),
     main = "")
title("Epanechnikov", line = 1)

# Quartic
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "quartic"),
     main = "")
title("Quartic", line = 1)

# Disc
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "disc"),
     main = "")
title("Disc", line = 1)

```

### Fixed and Adaptive KDE

#### Computing KDE by using fixed bandwidth

Next, we will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of childcareSG_ppp_km object is in kilometer, hence the 600m is 0.6km.

```{r}
kde_childcareSG_ab <- adaptive.density(childcareSG_ppp_km,
                                       sigma = bw.diggle,
                                       edge  = TRUE)
par(mar = c(4, 4, 6, 2))  # more space at top
plot(kde_childcareSG_ab, main = "Kernel Density of Childcare Services")


```

We can compare the fixed and adaptive kernel density estimation outputs by using the code chunk below.

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG_fb, main = "Fixed bandwidth")
plot(kde_childcareSG_ab, main = "Adaptive bandwidth")
```

#### Computing KDE by using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

```{r}
kde_childcareSG_ab <- adaptive.density(
  childcareSG_ppp_km, 
  method="kernel")
plot(kde_childcareSG_ab)
```

```{r}
library(spatstat.geom)
summary(childcareSG_ppp_km)        # look at 'window' units and ranges
unitname(childcareSG_ppp_km)       # should say "kilometre"
```

### Plotting cartographic quality KDE map

#### Converting gridded output into raster

Next, we will convert the im kernal density objects into SpatRaster object by using rast() of terra package.

```{r}
kde_childcareSG_bw_terra <- rast(kde_childcareSG_km)
class(kde_childcareSG_bw_terra)
kde_childcareSG_bw_terra
```

Notice that the crs property is empty. \#### Assigning projection systems In code chunk below, crs() of terra is used to assign the CRS information on kde_childcareSG_bw_terra layer.

```{r}
crs(kde_childcareSG_bw_terra) <- "EPSG:3414"
kde_childcareSG_bw_terra
```

#### Plotting KDE map with tmap

Finally, we will display the raster in cartographic quality map using tmap package.

```{r}
tm_shape(kde_childcareSG_bw_terra) + 
  tm_raster(col.scale = 
              tm_scale_continuous(
                values = "viridis"),
            col.legend = tm_legend(
            title = "Density values",
            title.size = 0.7,
            text.size = 0.7,
            bg.color = "white",
            bg.alpha = 0.7,
            position = tm_pos_in(
              "right", "bottom"),
            frame = TRUE)) +
  tm_graticules(labels.size = 0.7) +
  tm_compass() +
  tm_layout(scale = 1.0)
```

### First Order SPPA at the Planning Subzone Level

In this section, we would like to further our analysis at the planning area level. For simplicity reason, we will focus on Punggol, Tampines Chua Chu Kand and Jurong West planning areas

#### Geospatial data wrangling
```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
library(purrr)
library(rvest)

mpsz_sf <- mpsz_sf %>%
  mutate(
    REGION_N   = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N  = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C  = map_chr(Description, extract_kml_field, "SUBZONE_C")
  )
```
##### Extracting study area

```{r}
# Extract target planning areas
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf%>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

It is always a good practice to review the extracted areas. The code chunk below will be used to plot the extracted planning areas.
```{r}
par(mfrow=c(2,2))
plot(st_geometry(pg), main = "Ponggol")
plot(st_geometry(tm), main = "Tampines")
plot(st_geometry(ck), main = "Choa Chu Kang")
plot(st_geometry(jw), main = "Jurong West")
```
#####  Creating owin object 
Now, we will convert these sf objects into owin objects that is required by spatstat.
```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

##### Combining point events object and owin object
```{r}
childcare_pg_ppp = childcare_ppp[pg_owin]
childcare_tm_ppp = childcare_ppp[tm_owin]
childcare_ck_ppp = childcare_ppp[ck_owin]
childcare_jw_ppp = childcare_ppp[jw_owin]
```

Next, rescale.ppp() function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
childcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, "km")
```

The code chunk below is used to plot these four study areas and the locations of the childcare centres.

```{r}
par(mfrow=c(2,2))

plot(unmark(childcare_pg_ppp.km), 
     main="Punggol", pch=20, cex=0.6)

plot(unmark(childcare_tm_ppp.km), 
     main="Tampines", pch=20, cex=0.6)

plot(unmark(childcare_ck_ppp.km), 
     main="Choa Chu Kang", pch=20, cex=0.6)

plot(unmark(childcare_jw_ppp.km), 
     main="Jurong West", pch=20, cex=0.6)

```
####  Clark and Evans Test
##### Choa Chu Kang planning area
In the code chunk below, clarkevans.test() of spatstat is used to performs Clark-Evans test of aggregation for childcare centre in Choa Chu Kang planning area.

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```
##### Tampines planning area
In the code chunk below, the similar test is used to analyse the spatial point patterns of childcare centre in Tampines planning area.
```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```
####  Computing KDE surfaces by planning area
The code chunk below will be used to compute the KDE of these four planning area. bw.diggle method is used to derive the bandwidth of each

```{r}
par(mfrow=c(2,2))

# Punggol
plot(density(childcare_pg_ppp.km,
             sigma = bw.diggle(childcare_pg_ppp.km),
             edge = TRUE, kernel="gaussian"),
     main = "Punggol")

# Tampines
plot(density(childcare_tm_ppp.km,
             sigma = bw.diggle(childcare_tm_ppp.km),
             edge = TRUE, kernel="gaussian"),
     main = "Tampines")

# Choa Chu Kang
plot(density(childcare_ck_ppp.km,
             sigma = bw.diggle(childcare_ck_ppp.km),
             edge = TRUE, kernel="gaussian"),
     main = "Choa Chu Kang")

# Jurong West
plot(density(childcare_jw_ppp.km,
             sigma = bw.diggle(childcare_jw_ppp.km),
             edge = TRUE, kernel="gaussian"),
     main = "Jurong West")

```
