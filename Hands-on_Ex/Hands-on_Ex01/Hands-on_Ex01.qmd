---
title: "Hands-on Exercise 1"
author: "Gautamgovan"
date: "Aug 20, 2025"
date-modified: "last-modified"
format: 
  html:
    toc: true
    number-sections: true
execute: 
  echo: true
  eval: true
  warning: false
  freeze: true 
---

## Overview

In this Hands on Exercise we will be perfoming basic Geospatial data Wrangling and Covering basics of Thematic Mapping

## Geospatial Data Wrangling R

### Getting Started

Install and launching R packages

The code chunk below uses p_load() of pacman package to check if sf and tidyverse packages are installed in the computer. If they are, then they will be launched into R.

```{r}
pacman::p_load(sf,tidyverse)
```

### Importing Geospatial data

In this section, I have imported the following geospatial data into R by using `st_read()` of the **sf** package:

-   **MP14_SUBZONE_WEB_PL**, a polygon feature layer in ESRI shapefile (`.shp`) format, which I downloaded and extracted into the `geospatial` folder.\
-   **CyclingPath**, a line feature layer in ESRI shapefile (`.shp`) format, which I downloaded and stored in the same `geospatial` folder.\
-   **PreSchools**, a point feature layer in GeoJSON (`.geojson`) format (instead of the KML version), which I also saved into the `geospatial` folder.

#### Importing polygon feature data in shapefile format

The code chunk below uses st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a polygon feature data frame.

```{r}
# Base folder for datasets
gp <- "C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/geospatial"


mpsz <- st_read(dsn = gp, layer = "MP14_SUBZONE_WEB_PL")
```

#### Importing polyline feature data in shapefile form

The code chunk below uses st_read() function of sf package to import CyclingPath shapefile into R as line feature data frame.

```{r}
cyclingpath = st_read(dsn = gp, 
                         layer = "CyclingPathGazette")
```

#### Importing GIS data in kml format

The PreSchoolsLocation is in kml format. The code chunk below will be used to import the kml into R.

```{r}
preschools <- st_read("C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/geospatial/PreSchoolsLocation.kml")
```

### Checking the Content of A Simple Feature Data Frame

#### Working with st_geometry()

```{r}
st_geometry(mpsz)
```

#### Working with glimpse()

```{r}
glimpse(mpsz)
```

glimpse() report reveals the data type of each fields. For example FMEL-UPD_D field is in date data type and X_ADDR, Y_ADDR, SHAPE_L and SHAPE_AREA fields are all in double-precision values. \#### Working with head() In R, the head() function is used to look at the first few rows of a dataset or object.

```{r}
head(mpsz,n=5)
```

### Plotting the Geospatial Data

The plot() function in R is used to quickly visualize data or spatial objects (like shapefiles, points, or polygons) as a simple graph or map.

```{r}
plot(mpsz)
```

The default plot of an sf object is a multi-plot of all attributes, up to a reasonable maximum as shown above. We can, however, choose to plot only the geometry by using the code chunk below.

```{r}
plot(st_geometry(mpsz))
```

Alternatively, we can also choose the plot the sf object by using a specific attribute as shown in the code chunk below.

```{r}
plot(mpsz["PLN_AREA_N"])
```

Now, let us plot the preschool layer ontop of the mpsz layer by using the code chunk below.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschools), 
     add = TRUE)
```

The preschool points failed to plot on top of the mpsz layer because the two layers use different CRS (coordinate reference systems). \### Working with Projection Map projection is an important property of a geospatial data. In order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate system. \#### Assigning EPSG code to a simple feature data frame One of the common issue that can happen during importing geospatial data into R is that the coordinate system of the source data was either missing (such as due to missing .proj for ESRI shapefile) or wrongly assigned during the importing process.

```{r}
st_crs(mpsz)
```

Although mpsz data frame is projected in svy21 but when we read until the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.

In order to assign the correct EPSG code to mpsz data frame, st_set_crs() of sf package is used as shown in the code chunk below.

```{r}
mpsz <- st_set_crs(mpsz, 3414)
st_crs(mpsz)
```

Notice that the EPSG code is 3414 now. \#### Transforming the projection of preschool from wgs84 to svy21. In geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system. This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements. Let us perform the projection transformation by using the code chunk below.

```{r}
preschools <- st_transform(preschools, crs = 3414)
st_geometry(preschools)
```

Notice that it is in svy21 projected coordinate system now.

Now, let us try to plot the preschool layer ontop of mpsz layer again by using the similar code chunk used earlier.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschools), add = TRUE)
```

### Importing and Converting An Aspatial Data

For the purpose of this exercise, the listings.csv data downloaded from AirBnb will be used. \#### Importing the aspatial data Since listings data set is in csv file format, we will use read_csv() of readr package to import listing.csv as shown the code chunk below.

```{r}
listings <- read_csv("C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/aspatial/listings.csv")
list(listings)
```

Two useful fields we are going to use in the next phase are latitude and longitude. \#### Creating a simple feature data frame from an aspatial data frame The code chunk below converts listing data frame into a simple feature data frame by using st_as_sf() of sf packages

```{r}
listings_sf <- listings %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>%
  st_transform(crs = 3414)
glimpse(listings_sf)
```

```{r}
# Plot subzone polygons first
plot(st_geometry(mpsz), 
     main = "Airbnb Listings on Subzones of Singapore")

# Add Airbnb listings on top
plot(st_geometry(listings_sf), add = TRUE)
```

### Geoprocessing with sf package

Besides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions.

#### Use case 1: Land acquisition analysis

##### The scenario

The authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the existing cycling path. We are tasked to determine the extend of the land need to be acquired and their total area.

##### The Solution

To determine the extent of land needed for the cycling path upgrade, we first created 5-meter buffers around the existing cycling paths. After generating the buffers, we calculated their areas and then summed them up to obtain the total land involved in the acquisition, which amounted to 3,561,648 square metres.

To better understand the distribution of the required land, we focused on a specific case in the Tampines West planning subzone. We filtered out this subzone from the master plan and clipped the cycling path buffers within its boundaries. Finally, we plotted the results to visualize the buffered cycling paths inside Tampines West.

```{r}
# 1. Create 5m buffer around cycling paths
buffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)

# 2. Calculate buffer area
buffer_cycling <- buffer_cycling %>%
  mutate(AREA = st_area(geometry))

# 3. Total area of land to be acquired
total_area <- sum(buffer_cycling$AREA)
print(total_area)

# 4. Select Tampines West subzone
mpsz_selected <- mpsz %>%
  filter(SUBZONE_N == "TAMPINES WEST")

#transformation
buffer_cycling <- st_transform(buffer_cycling, st_crs(mpsz))


# 5. Clip buffer within Tampines West subzone
buffer_cycling_selected <- st_intersection(buffer_cycling, mpsz_selected)

# 6. Plot results
plot(st_geometry(mpsz_selected), main = "Cycling Path Buffer in Tampines West")
plot(st_geometry(buffer_cycling_selected), col = "lightblue", add = TRUE)
plot(st_geometry(cyclingpath), col = "red", lwd = 2, add = TRUE)
```

#### Use case 2: To determine the number of pre-schools by planning subzone

##### The scenario

The authority requires a count of pre-schools for each planning subzone to support forward planning. Using R and the sf package, we are going to perform the necessary geoprocessing to compute these counts and present the results clearly. \##### 1.9.2.2 The solution The code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.

```{r}
mpsz$`PreSch Count`<- lengths(st_intersects(mpsz, preschools))
summary(mpsz$`PreSch Count`)
```

To list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.

```{r}
top_n(mpsz, 1, `PreSch Count`)
```

In the code chunk below, another geoprocessing function of sf package called st_area() is used to derive the area of each planning subzone.

```{r}
mpsz$Area <- mpsz %>%
  st_area()
```

Next, mutate() of dplyr package is used to compute the density by using the code chunk below.

```{r}
mpsz <- mpsz %>%
  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)
```

Firstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.

```{r}
hist(mpsz$`PreSch Density`)
```

In code chunk below we made changes to improve the quality of the visualisation.

```{r}
ggplot(data=mpsz, 
       aes(x= as.numeric(`PreSch Density`)))+
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(title = "Are pre-school even distributed in Singapore?",
       subtitle= "There are many planning subzones with a single pre-school, on the other hand, \nthere are seven planning subzones with at least 30 or more pre-schools",
      x = "Pre-school density (per km sq)",
      y = "Frequency")
```

In the code chunk below, appropriate ggplot2 functions are used to plot a scatterplot showing the relationship between Pre-school Density and Pre-school Count.

```{r}
ggplot(data=mpsz, 
       aes(y = `PreSch Count`, 
           x= as.numeric(`PreSch Density`)))+
  geom_point(color="black", 
             fill="light blue") +
  xlim(0, 40) +
  ylim(0, 40) +
  labs(title = "",
      x = "Pre-school density (per km sq)",
      y = "Pre-school count")
```

## Thematic Mapping and GeoVisualisation with R

###Overview In general, thematic mapping involves the use of map symbols to visualize selected properties of geographic features that are not naturally visible, such as population, temperature, crime rate, and property prices, just to mention a few of them.

Geovisualisation, on the other hand, is the process of using visual representations and cartographic techniques to explore, analyze, and communicate geospatial data. It combines elements of cartography, computer science, and information visualization to enhance spatial understanding and knowledge discovery.

### Getting Started

In this hands-on exercise, the key R package used is [**tmap**](https://cran.r-project.org/package=tmap) in R.\
Besides **tmap**, five other R packages will be used. They are:

-   [**readr**](https://cran.r-project.org/package=readr) for importing delimited text files,\
-   [**tidyr**](https://cran.r-project.org/package=tidyr) for tidying data,\
-   [**dplyr**](https://cran.r-project.org/package=dplyr) for wrangling data,\
-   [**sf**](https://cran.r-project.org/package=sf) for handling geospatial data, and\
-   [**rvest**](https://cran.r-project.org/package=rvest) for scraping (or harvesting) data from web pages.

Among the five packages, **readr**, **tidyr**, and **dplyr** are part of the **tidyverse** package.

The code chunk below will be used to install and load these packages in RStudio.

```{r}
pacman::p_load(sf, tmap, tidyverse, rvest)
```

### Importing Data into R

#### Importing Geospatial Data into R

The code chunk below uses the st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a simple feature data frame called mpsz.

```{r}
mpsz <- st_read("C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```

##### Tidying data

Function to extract values from the HTML description

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

```{r}
mpsz
```

#### Importing Attribute Data into R

Next, we will be importing the respopagesextod2024.csv file into RStudio and saving it as a tibble dataframe called popdata.

We will perform this task by using the read_csv() function from the readr package, as shown in the code chunk below.

```{r}
popdata <- readr::read_csv("C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/aspatial/respopagesextod2024.csv")
```

##### Data Preparation

###### Data wrangling

The following data wrangling and transformation functions will be used:

-   pivot_wider() of tidyr package, and
-   mutate(), filter(), group_by() and select() of dplyr package

```{r}
popdata2024 <- popdata %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

###### Joining the attribute data and geospatial data

Before we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.

```{r}
# 1. Clean and filter popdata2024
popdata2024 <- popdata2024 %>%
  mutate_at(.vars = vars(PA, SZ),
            .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)

# 2. Join with subzone boundaries
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))

# 3. Save the result
write_rds(mpsz_pop2024,
          "C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/rds/mpsz_pop2024.rds")
```

### Choropleth Mapping Geospatial Data Using tmap

Two approaches can be used to prepare thematic map using **tmap**, they are:

-   Plotting a thematic map quickly by using *qtm()*.
-   Plotting highly customisable thematic map by using **tmap** elements.

#### Plotting a choropleth map quickly by using qtm()

The easiest and quickest to draw a choropleth map using tmap is using qtm(). It is concise and provides a good default visualisation in many cases.

The code chunk below will draw a cartographic standard choropleth map as shown below.

```{r}
tmap_mode("plot")
qtm(shp = mpsz_pop2024, 
    fill = "DEPENDENCY")
```

Things to learn from the code chunk above:

-   tmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.
-   fill argument is used to map the attribute (i.e. DEPENDENCY)

#### Creating a choropleth map by using tmap’s elements
Despite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of qtm() is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.
```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by planning subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```
In the following sub-section, we will share with you tmap functions that used to plot these elements.
##### Drawing a base map
The basic building block of tmap is tm_shape() followed by one or more layer elemments such as tm_polygons(), tm_symbols(), tm_lines(), tm_raster() and tm_text().

In the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2024) and tm_polygons() is used to draw the planning subzone polygons
```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons()
```
##### Drawing a choropleth map using tm_polygons()
To draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().
```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY")
```
##### Drawing a choropleth map using tm_fill() and **tm_border()**
Actually, tm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the polygon features onto the choropleth map.

The code chunk below draws a choropleth map by using tm_fill() alone.
```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY")
```
To add the boundary of the planning subzones, tm_borders() will be used as shown in the code chunk below.
```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders()
```
Notice that light-gray border lines have been added on the choropleth map.

The fill_alpha argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).

Beside fill_alpha argument, there are three other arguments for tm_borders(), they are:

- col = border colour,
- lwd = border line width. The default is 1, and
- lty = border line type. The default is “solid”.
```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```
#### Data classification methods of tmap
Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.

tmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.

To define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.

##### Plotting choropleth maps with built-in classification methods
The code chunk below shows a quantile data classification that used 5 classes.
```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```
In the code chunk below, equal data classification method is used.
```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```
```{r}

tmap_mode("plot")

# Helper to build one choropleth with chosen style + classes
make_map <- function(style = "quantile", n = 5, title = NULL) {
  tm_shape(mpsz_pop2024) +
    tm_polygons(
      fill = "DEPENDENCY",
      fill.scale = tm_scale_intervals(style = style, n = n, values = "brewer.blues"),
      fill.legend = tm_legend(title = title %||% paste0("Style: ", style, " (n=", n, ")"))
    ) +
    tm_borders(col = "grey40", lwd = 0.3, fill_alpha = 0.5) +
    tm_layout(frame = TRUE)
}

# ---------- DIY 1: Compare classification methods ----------
map_quantile <- make_map("quantile", 5, "Quantile (n=5)")
map_equal    <- make_map("equal",    5, "Equal (n=5)")
map_pretty   <- make_map("pretty",   5, "Pretty (n=5)")
map_jenks    <- make_map("jenks",    5, "Jenks (n=5)")
map_kmeans   <- make_map("kmeans",   5, "K-means (n=5)")

tmap_arrange(map_quantile, map_equal, map_pretty, map_jenks, map_kmeans, nrow = 2)

# ---------- DIY 2: Same method, different numbers of classes ----------
q2  <- make_map("quantile", 2,  "Quantile (n=2)")
q6  <- make_map("quantile", 6,  "Quantile (n=6)")
q10 <- make_map("quantile", 10, "Quantile (n=10)")
q20 <- make_map("quantile", 20, "Quantile (n=20)")

tmap_arrange(q2, q6, q10, q20, nrow = 2)
```
- Different **classification methods** change how patterns are revealed:  
  - *Quantile* shows relative ranking clearly but can split similar values.  
  - *Equal* bins exaggerate extremes when data are skewed.  
  - *Jenks* and *K-means* highlight natural clusters more effectively.  

- The **number of classes** affects readability:  
  - Few classes (2–4) oversimplify the data and hide variation.  
  - Moderate classes (5–7) balance detail and clarity — best for reporting.  
  - Many classes (10–20) make the map cluttered and hard to interpret.  

- For communication and decision-making, **Jenks or Quantile with ~5–7 classes** gives the clearest insights.

##### Plotting choropleth map with custome break
For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_scale_intervals(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).

Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.
```{r}
summary(mpsz_pop2024$DEPENDENCY)
```
With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, we will plot the choropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```
#### Colour Scheme
tmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.

#####  Using ColourBrewer palette
To change the colour, we assign the preferred colour to palette argument of values as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```
Notice that the choropleth map is shaded in green.

To reverse the colour shading, add a “-” prefix.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```
##### Cartographic Furniture
Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, tm_compass(), tm_scale_bar(), tm_grid() and tm_credit() are used to add compass, scale bar, grid lines and data sources onto the choropleth map.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```
#### Map Layout
Map layout refers to the combination of all map elements into a cohensive map. It includes the map background, frame, typography, scale, aspect ratio, margins, and more.

We can customize the map layout using the tm_layout() function.

#####  Map Legend
In tmap, several legend options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```
##### Map Style
tmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().

The code chunk below shows the classic style is used.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")
```
To reset use the code below 
```{r}
tmap_style("white")
```

### Drawing Small Multiple Choropleth Maps

Small multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In tmap, small multiple maps can be plotted in three ways:

- by assigning multiple values to at least one of the asthetic arguments,
- by creating multiple stand-alone maps with tmap_arrange(), and
- by defining a group-by variable in tm_facets().

#### By assigning multiple values to at least one of the aesthetic arguments
In this example, small multiple choropleth maps are created by assigning two variables to the visual variable (i.e. fill).

```{r}
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```
##### By arrange multiples choropleth maps in a grid layout
In this example, multiple choropleth maps are created and tmap_arrnage() is used to arrnage them in a grid layout.

```{r}
youngmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                  item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")
                
agedmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
              style = "quantile", 
              values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of aged population")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```
#### By defining a group-by variable in tm_facets()
In this example, multiple small choropleth maps are created by using
tm_facets().

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```
### Mappping Spatial Object Meeting a Selection Criterion

Instead of creating small multiple choropleth map, you can also use filter() of dplyr package to select geographical area of interest and plot a choropleth map focus only on the selected region.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```
### Complementing Thematic Map with Statistical Chart
Maps and statistical charts complement each other by visually representing different aspects of the same data, offering a more comprehensive understanding. Maps excel at showing spatial relationships and geographical patterns, while charts effectively display numerical data, trends, and comparisons. Combining both allows for a more insightful and engaging data narrative, especially when dealing with spatial data that also has quantifiable characteristics.

With tmap, statistical chart and be incorporate into the map visualisation by using fill.chat argument of map layers and legend chart feature as shown in the code chunk below.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders() +
  tm_layout(asp = 0.8)
```
In the code chunk below, We improve the visual representation further by highlighting and lebaling the outliers on the choropleth map.

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile", 
            values = "brewer.blues"),
          fill.legend = tm_legend(),
          fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```
### Creating Interactive Maps

Interactive maps let users actively explore and interact with the data they display. Unlike static maps, you can zoom in and out, pan across areas, click on locations for more information, and even work with data overlays or visualizations—making the experience more dynamic and informative. One of the great things about tmap is that it lets you switch easily between static and interactive maps using tmap_mode(), so you can choose the view that best suits your analysis.

By modifying the code chunk in sub-section 3.5, the code chunks below build an interactive map using
```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```
```{r}
tmap_mode("plot")
```

The interactive map above is far from satisfactory. While we want to encourage users to engage and explore the interactive by zooming in and out of the study area freely. But, users might lost in the cyberspace with too much freedom to zoom-in and zoom-out.

To address this issue, set_zoom_limits argument can be used to limit the map extend users can zooming in and out of the map areas as shown below.

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")

tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_zoom_limits = c(12,14))
tmap_mode("plot")
```

