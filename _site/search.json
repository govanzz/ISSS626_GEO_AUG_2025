[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS626",
    "section": "",
    "text": "Welcome to ISSS626 Geospatial Analytics and Applications\nIn this website, you will find my coursework prepared for this course\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "In this Hands on Exercise we will be perfoming basic Geospatial data Wrangling and Covering basics of Thematic Mapping"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#overview",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#overview",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "In this Hands on Exercise we will be perfoming basic Geospatial data Wrangling and Covering basics of Thematic Mapping"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geospatial-data-wrangling-r",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geospatial-data-wrangling-r",
    "title": "Hands-on Exercise 1",
    "section": "2 Geospatial Data Wrangling R",
    "text": "2 Geospatial Data Wrangling R\n\n2.1 Getting Started\nInstall and launching R packages\nThe code chunk below uses p_load() of pacman package to check if sf and tidyverse packages are installed in the computer. If they are, then they will be launched into R.\n\npacman::p_load(sf,tidyverse)\n\n\n\n2.2 Importing Geospatial data\nIn this section, I have imported the following geospatial data into R by using st_read() of the sf package:\n\nMP14_SUBZONE_WEB_PL, a polygon feature layer in ESRI shapefile (.shp) format, which I downloaded and extracted into the geospatial folder.\n\nCyclingPath, a line feature layer in ESRI shapefile (.shp) format, which I downloaded and stored in the same geospatial folder.\n\nPreSchools, a point feature layer in GeoJSON (.geojson) format (instead of the KML version), which I also saved into the geospatial folder.\n\n\n2.2.1 Importing polygon feature data in shapefile format\nThe code chunk below uses st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a polygon feature data frame.\n\n# Base folder for datasets\ngp &lt;- \"C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/geospatial\"\n\n\nmpsz &lt;- st_read(dsn = gp, layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\govanzz\\ISSS626_GEO_AUG_2025\\Hands-on_Ex\\Hands-on_Ex01\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\n2.2.2 Importing polyline feature data in shapefile form\nThe code chunk below uses st_read() function of sf package to import CyclingPath shapefile into R as line feature data frame.\n\ncyclingpath = st_read(dsn = gp, \n                         layer = \"CyclingPathGazette\")\n\nReading layer `CyclingPathGazette' from data source \n  `C:\\govanzz\\ISSS626_GEO_AUG_2025\\Hands-on_Ex\\Hands-on_Ex01\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 4651 features and 19 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 11721.1 ymin: 27550.13 xmax: 42809.37 ymax: 49702.59\nProjected CRS: SVY21\n\n\n\n\n2.2.3 Importing GIS data in kml format\nThe PreSchoolsLocation is in kml format. The code chunk below will be used to import the kml into R.\n\npreschools &lt;- st_read(\"C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/geospatial/PreSchoolsLocation.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `C:\\govanzz\\ISSS626_GEO_AUG_2025\\Hands-on_Ex\\Hands-on_Ex01\\data\\geospatial\\PreSchoolsLocation.kml' \n  using driver `KML'\nSimple feature collection with 2290 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\n\n\n2.3 Checking the Content of A Simple Feature Data Frame\n\n2.3.1 Working with st_geometry()\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\n\n\n2.3.2 Working with glimpse()\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO &lt;int&gt; 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  &lt;chr&gt; \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  &lt;chr&gt; \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     &lt;chr&gt; \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N &lt;chr&gt; \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C &lt;chr&gt; \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   &lt;chr&gt; \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   &lt;chr&gt; \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    &lt;chr&gt; \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D &lt;date&gt; 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     &lt;dbl&gt; 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     &lt;dbl&gt; 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng &lt;dbl&gt; 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area &lt;dbl&gt; 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\nglimpse() report reveals the data type of each fields. For example FMEL-UPD_D field is in date data type and X_ADDR, Y_ADDR, SHAPE_L and SHAPE_AREA fields are all in double-precision values. #### Working with head() In R, the head() function is used to look at the first few rows of a dataset or object.\n\nhead(mpsz,n=5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n\n\n\n\n\n2.4 Plotting the Geospatial Data\nThe plot() function in R is used to quickly visualize data or spatial objects (like shapefiles, points, or polygons) as a simple graph or map.\n\nplot(mpsz)\n\n\n\n\n\n\n\n\nThe default plot of an sf object is a multi-plot of all attributes, up to a reasonable maximum as shown above. We can, however, choose to plot only the geometry by using the code chunk below.\n\nplot(st_geometry(mpsz))\n\n\n\n\n\n\n\n\nAlternatively, we can also choose the plot the sf object by using a specific attribute as shown in the code chunk below.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\n\n\n\nNow, let us plot the preschool layer ontop of the mpsz layer by using the code chunk below.\n\nplot(st_geometry(mpsz))\nplot(st_geometry(preschools), \n     add = TRUE)\n\n\n\n\n\n\n\n\nThe preschool points failed to plot on top of the mpsz layer because the two layers use different CRS (coordinate reference systems). ### Working with Projection Map projection is an important property of a geospatial data. In order to perform geoprocessing using two geospatial data, we need to ensure that both geospatial data are projected using similar coordinate system. #### Assigning EPSG code to a simple feature data frame One of the common issue that can happen during importing geospatial data into R is that the coordinate system of the source data was either missing (such as due to missing .proj for ESRI shapefile) or wrongly assigned during the importing process.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\nAlthough mpsz data frame is projected in svy21 but when we read until the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.\nIn order to assign the correct EPSG code to mpsz data frame, st_set_crs() of sf package is used as shown in the code chunk below.\n\nmpsz &lt;- st_set_crs(mpsz, 3414)\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nNotice that the EPSG code is 3414 now. #### Transforming the projection of preschool from wgs84 to svy21. In geospatial analytics, it is very common for us to transform the original data from geographic coordinate system to projected coordinate system. This is because geographic coordinate system is not appropriate if the analysis need to use distance or/and area measurements. Let us perform the projection transformation by using the code chunk below.\n\npreschools &lt;- st_transform(preschools, crs = 3414)\nst_geometry(preschools)\n\nGeometry set for 2290 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11810.03 ymin: 25596.33 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nNotice that it is in svy21 projected coordinate system now.\nNow, let us try to plot the preschool layer ontop of mpsz layer again by using the similar code chunk used earlier.\n\nplot(st_geometry(mpsz))\nplot(st_geometry(preschools), add = TRUE)\n\n\n\n\n\n\n\n\n\n\n2.5 Importing and Converting An Aspatial Data\nFor the purpose of this exercise, the listings.csv data downloaded from AirBnb will be used. #### Importing the aspatial data Since listings data set is in csv file format, we will use read_csv() of readr package to import listing.csv as shown the code chunk below.\n\nlistings &lt;- read_csv(\"C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/aspatial/listings.csv\")\nlist(listings)\n\n[[1]]\n# A tibble: 3,659 × 18\n       id name      host_id host_name neighbourhood_group neighbourhood latitude\n    &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;               &lt;chr&gt;            &lt;dbl&gt;\n 1  71609 Ensuite …  367042 Belinda   East Region         Tampines          1.35\n 2  71896 B&B  Roo…  367042 Belinda   East Region         Tampines          1.35\n 3  71903 Room 2-n…  367042 Belinda   East Region         Tampines          1.35\n 4 275343 10min wa… 1439258 Kay       Central Region      Bukit Merah       1.29\n 5 275344 15 mins … 1439258 Kay       Central Region      Bukit Merah       1.29\n 6 294281 5 mins w… 1521514 Elizabeth Central Region      Newton            1.31\n 7 324945 Comforta… 1439258 Kay       Central Region      Bukit Merah       1.29\n 8 330095 Relaxing… 1439258 Kay       Central Region      Bukit Merah       1.29\n 9 344803 Budget s…  367042 Belinda   East Region         Tampines          1.35\n10 369141 5mins fr… 1521514 Elizabeth Central Region      Newton            1.31\n# ℹ 3,649 more rows\n# ℹ 11 more variables: longitude &lt;dbl&gt;, room_type &lt;chr&gt;, price &lt;dbl&gt;,\n#   minimum_nights &lt;dbl&gt;, number_of_reviews &lt;dbl&gt;, last_review &lt;date&gt;,\n#   reviews_per_month &lt;dbl&gt;, calculated_host_listings_count &lt;dbl&gt;,\n#   availability_365 &lt;dbl&gt;, number_of_reviews_ltm &lt;dbl&gt;, license &lt;chr&gt;\n\n\nTwo useful fields we are going to use in the next phase are latitude and longitude. #### Creating a simple feature data frame from an aspatial data frame The code chunk below converts listing data frame into a simple feature data frame by using st_as_sf() of sf packages\n\nlistings_sf &lt;- listings %&gt;%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"), crs = 4326) %&gt;%\n  st_transform(crs = 3414)\nglimpse(listings_sf)\n\nRows: 3,659\nColumns: 17\n$ id                             &lt;dbl&gt; 71609, 71896, 71903, 275343, 275344, 29…\n$ name                           &lt;chr&gt; \"Ensuite Room (Room 1 & 2) near EXPO\", …\n$ host_id                        &lt;dbl&gt; 367042, 367042, 367042, 1439258, 143925…\n$ host_name                      &lt;chr&gt; \"Belinda\", \"Belinda\", \"Belinda\", \"Kay\",…\n$ neighbourhood_group            &lt;chr&gt; \"East Region\", \"East Region\", \"East Reg…\n$ neighbourhood                  &lt;chr&gt; \"Tampines\", \"Tampines\", \"Tampines\", \"Bu…\n$ room_type                      &lt;chr&gt; \"Private room\", \"Private room\", \"Privat…\n$ price                          &lt;dbl&gt; 143, NA, 76, NA, NA, 85, NA, NA, 41, 79…\n$ minimum_nights                 &lt;dbl&gt; 92, 92, 92, 180, 180, 92, 180, 180, 92,…\n$ number_of_reviews              &lt;dbl&gt; 19, 24, 46, 20, 16, 131, 17, 5, 60, 81,…\n$ last_review                    &lt;date&gt; 2020-01-17, 2019-10-13, 2020-01-09, 20…\n$ reviews_per_month              &lt;dbl&gt; 0.12, 0.14, 0.27, 0.13, 0.10, 0.80, 0.1…\n$ calculated_host_listings_count &lt;dbl&gt; 5, 5, 5, 58, 58, 7, 58, 58, 5, 7, 7, 1,…\n$ availability_365               &lt;dbl&gt; 90, 79, 90, 153, 153, 365, 153, 153, 36…\n$ number_of_reviews_ltm          &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, …\n$ license                        &lt;chr&gt; NA, NA, NA, \"S0399\", \"S0399\", NA, \"S039…\n$ geometry                       &lt;POINT [m]&gt; POINT (41972.5 36390.05), POINT (…\n\n\n\n# Plot subzone polygons first\nplot(st_geometry(mpsz), \n     main = \"Airbnb Listings on Subzones of Singapore\")\n\n# Add Airbnb listings on top\nplot(st_geometry(listings_sf), add = TRUE)\n\n\n\n\n\n\n\n\n\n\n2.6 Geoprocessing with sf package\nBesides providing functions to handling (i.e. importing, exporting, assigning projection, transforming projection etc) geospatial data, sf package also offers a wide range of geoprocessing (also known as GIS analysis) functions.\n\n2.6.1 Use case 1: Land acquisition analysis\n\n2.6.1.1 The scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the existing cycling path. We are tasked to determine the extend of the land need to be acquired and their total area.\n\n\n2.6.1.2 The Solution\nTo determine the extent of land needed for the cycling path upgrade, we first created 5-meter buffers around the existing cycling paths. After generating the buffers, we calculated their areas and then summed them up to obtain the total land involved in the acquisition, which amounted to 3,561,648 square metres.\nTo better understand the distribution of the required land, we focused on a specific case in the Tampines West planning subzone. We filtered out this subzone from the master plan and clipped the cycling path buffers within its boundaries. Finally, we plotted the results to visualize the buffered cycling paths inside Tampines West.\n\n# 1. Create 5m buffer around cycling paths\nbuffer_cycling &lt;- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\n# 2. Calculate buffer area\nbuffer_cycling &lt;- buffer_cycling %&gt;%\n  mutate(AREA = st_area(geometry))\n\n# 3. Total area of land to be acquired\ntotal_area &lt;- sum(buffer_cycling$AREA)\nprint(total_area)\n\n3561648 [m^2]\n\n# 4. Select Tampines West subzone\nmpsz_selected &lt;- mpsz %&gt;%\n  filter(SUBZONE_N == \"TAMPINES WEST\")\n\n#transformation\nbuffer_cycling &lt;- st_transform(buffer_cycling, st_crs(mpsz))\n\n\n# 5. Clip buffer within Tampines West subzone\nbuffer_cycling_selected &lt;- st_intersection(buffer_cycling, mpsz_selected)\n\n# 6. Plot results\nplot(st_geometry(mpsz_selected), main = \"Cycling Path Buffer in Tampines West\")\nplot(st_geometry(buffer_cycling_selected), col = \"lightblue\", add = TRUE)\nplot(st_geometry(cyclingpath), col = \"red\", lwd = 2, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n2.6.2 Use case 2: To determine the number of pre-schools by planning subzone\n\n2.6.2.1 The scenario\nThe authority requires a count of pre-schools for each planning subzone to support forward planning. Using R and the sf package, we are going to perform the necessary geoprocessing to compute these counts and present the results clearly. ##### 1.9.2.2 The solution The code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz$`PreSch Count`&lt;- lengths(st_intersects(mpsz, preschools))\nsummary(mpsz$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    4.00    7.09   10.00   72.00 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 39655.33 ymin: 35966 xmax: 42940.57 ymax: 38622.37\nProjected CRS: SVY21 / Singapore TM\n  OBJECTID SUBZONE_NO     SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n1      189          2 TAMPINES EAST    TMSZ02      N   TAMPINES         TM\n     REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR   Y_ADDR SHAPE_Leng\n1 EAST REGION       ER 21658EAAF84F4D8D 2014-12-05 41122.55 37392.39   10180.62\n  SHAPE_Area                       geometry PreSch Count\n1    4339824 MULTIPOLYGON (((42196.76 38...           72\n\n\nIn the code chunk below, another geoprocessing function of sf package called st_area() is used to derive the area of each planning subzone.\n\nmpsz$Area &lt;- mpsz %&gt;%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz &lt;- mpsz %&gt;%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz$`PreSch Density`)\n\n\n\n\n\n\n\n\nIn code chunk below we made changes to improve the quality of the visualisation.\n\nggplot(data=mpsz, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning subzones with a single pre-school, on the other hand, \\nthere are seven planning subzones with at least 30 or more pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions are used to plot a scatterplot showing the relationship between Pre-school Density and Pre-school Count.\n\nggplot(data=mpsz, \n       aes(y = `PreSch Count`, \n           x= as.numeric(`PreSch Density`)))+\n  geom_point(color=\"black\", \n             fill=\"light blue\") +\n  xlim(0, 40) +\n  ylim(0, 40) +\n  labs(title = \"\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Pre-school count\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#thematic-mapping-and-geovisualisation-with-r",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#thematic-mapping-and-geovisualisation-with-r",
    "title": "Hands-on Exercise 1",
    "section": "3 Thematic Mapping and GeoVisualisation with R",
    "text": "3 Thematic Mapping and GeoVisualisation with R\n###Overview In general, thematic mapping involves the use of map symbols to visualize selected properties of geographic features that are not naturally visible, such as population, temperature, crime rate, and property prices, just to mention a few of them.\nGeovisualisation, on the other hand, is the process of using visual representations and cartographic techniques to explore, analyze, and communicate geospatial data. It combines elements of cartography, computer science, and information visualization to enhance spatial understanding and knowledge discovery.\n\n3.1 Getting Started\nIn this hands-on exercise, the key R package used is tmap in R.\nBesides tmap, five other R packages will be used. They are:\n\nreadr for importing delimited text files,\n\ntidyr for tidying data,\n\ndplyr for wrangling data,\n\nsf for handling geospatial data, and\n\nrvest for scraping (or harvesting) data from web pages.\n\nAmong the five packages, readr, tidyr, and dplyr are part of the tidyverse package.\nThe code chunk below will be used to install and load these packages in RStudio.\n\npacman::p_load(sf, tmap, tidyverse, rvest)\n\n\n\n3.2 Importing Data into R\n\n3.2.1 Importing Geospatial Data into R\nThe code chunk below uses the st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a simple feature data frame called mpsz.\n\nmpsz &lt;- st_read(\"C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml\")\n\nReading layer `URA_MP19_SUBZONE_NO_SEA_PL' from data source \n  `C:\\govanzz\\ISSS626_GEO_AUG_2025\\Hands-on_Ex\\Hands-on_Ex01\\data\\geospatial\\MasterPlan2019SubzoneBoundaryNoSeaKML.kml' \n  using driver `KML'\nSimple feature collection with 332 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n\n\n\n3.2.1.1 Tidying data\nFunction to extract values from the HTML description\n\nextract_kml_field &lt;- function(html_text, field_name) {\n  if (is.na(html_text) || html_text == \"\") return(NA_character_)\n  \n  page &lt;- read_html(html_text)\n  rows &lt;- page %&gt;% html_elements(\"tr\")\n  \n  value &lt;- rows %&gt;%\n    keep(~ html_text2(html_element(.x, \"th\")) == field_name) %&gt;%\n    html_element(\"td\") %&gt;%\n    html_text2()\n  \n  if (length(value) == 0) NA_character_ else value\n}\n\n\nmpsz &lt;- mpsz %&gt;%\n  mutate(\n    REGION_N = map_chr(Description, extract_kml_field, \"REGION_N\"),\n    PLN_AREA_N = map_chr(Description, extract_kml_field, \"PLN_AREA_N\"),\n    SUBZONE_N = map_chr(Description, extract_kml_field, \"SUBZONE_N\"),\n    SUBZONE_C = map_chr(Description, extract_kml_field, \"SUBZONE_C\")\n  ) %&gt;%\n  select(-Name, -Description) %&gt;%\n  relocate(geometry, .after = last_col())\n\n\nmpsz\n\nSimple feature collection with 332 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\nFirst 10 features:\n         REGION_N    PLN_AREA_N           SUBZONE_N SUBZONE_C\n1  CENTRAL REGION   BUKIT MERAH          DEPOT ROAD    BMSZ12\n2  CENTRAL REGION   BUKIT MERAH         BUKIT MERAH    BMSZ02\n3  CENTRAL REGION        OUTRAM           CHINATOWN    OTSZ03\n4  CENTRAL REGION DOWNTOWN CORE             PHILLIP    DTSZ04\n5  CENTRAL REGION DOWNTOWN CORE       RAFFLES PLACE    DTSZ05\n6  CENTRAL REGION        OUTRAM        CHINA SQUARE    OTSZ04\n7  CENTRAL REGION   BUKIT MERAH         TIONG BAHRU    BMSZ10\n8  CENTRAL REGION DOWNTOWN CORE    BAYFRONT SUBZONE    DTSZ12\n9  CENTRAL REGION   BUKIT MERAH TIONG BAHRU STATION    BMSZ04\n10 CENTRAL REGION DOWNTOWN CORE       CLIFFORD PIER    DTSZ06\n                         geometry\n1  MULTIPOLYGON (((103.8145 1....\n2  MULTIPOLYGON (((103.8221 1....\n3  MULTIPOLYGON (((103.8438 1....\n4  MULTIPOLYGON (((103.8496 1....\n5  MULTIPOLYGON (((103.8525 1....\n6  MULTIPOLYGON (((103.8486 1....\n7  MULTIPOLYGON (((103.8311 1....\n8  MULTIPOLYGON (((103.8589 1....\n9  MULTIPOLYGON (((103.8283 1....\n10 MULTIPOLYGON (((103.8552 1....\n\n\n\n\n\n3.2.2 Importing Attribute Data into R\nNext, we will be importing the respopagesextod2024.csv file into RStudio and saving it as a tibble dataframe called popdata.\nWe will perform this task by using the read_csv() function from the readr package, as shown in the code chunk below.\n\npopdata &lt;- readr::read_csv(\"C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/aspatial/respopagesextod2024.csv\")\n\n\n3.2.2.1 Data Preparation\n\n3.2.2.1.1 Data wrangling\nThe following data wrangling and transformation functions will be used:\n\npivot_wider() of tidyr package, and\nmutate(), filter(), group_by() and select() of dplyr package\n\n\npopdata2024 &lt;- popdata %&gt;%\n  group_by(PA, SZ, AG) %&gt;%\n  summarise(`POP` = sum(`Pop`)) %&gt;%\n  ungroup()%&gt;%\n  pivot_wider(names_from=AG, \n              values_from=POP) %&gt;%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %&gt;%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%&gt;%\nmutate(`AGED`=rowSums(.[16:21])) %&gt;%\nmutate(`TOTAL`=rowSums(.[3:21])) %&gt;%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %&gt;%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n\n\n3.2.2.1.2 Joining the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\n\n# 1. Clean and filter popdata2024\npopdata2024 &lt;- popdata2024 %&gt;%\n  mutate_at(.vars = vars(PA, SZ),\n            .funs = list(toupper)) %&gt;%\n  filter(`ECONOMY ACTIVE` &gt; 0)\n\n# 2. Join with subzone boundaries\nmpsz_pop2024 &lt;- left_join(mpsz, popdata2024,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\n# 3. Save the result\nwrite_rds(mpsz_pop2024,\n          \"C:/govanzz/ISSS626_GEO_AUG_2025/Hands-on_Ex/Hands-on_Ex01/data/rds/mpsz_pop2024.rds\")\n\n\n\n\n\n\n3.3 Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\n3.3.1 Plotting a choropleth map quickly by using qtm()\nThe easiest and quickest to draw a choropleth map using tmap is using qtm(). It is concise and provides a good default visualisation in many cases.\nThe code chunk below will draw a cartographic standard choropleth map as shown below.\n\ntmap_mode(\"plot\")\nqtm(shp = mpsz_pop2024, \n    fill = \"DEPENDENCY\")\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n3.3.2 Creating a choropleth map by using tmap’s elements\nDespite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of qtm() is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\", \n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scalebar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\nIn the following sub-section, we will share with you tmap functions that used to plot these elements. ##### Drawing a base map The basic building block of tmap is tm_shape() followed by one or more layer elemments such as tm_polygons(), tm_symbols(), tm_lines(), tm_raster() and tm_text().\nIn the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2024) and tm_polygons() is used to draw the planning subzone polygons\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons()\n\n\n\n\n\n\n\n\n\n3.3.2.1 Drawing a choropleth map using tm_polygons()\nTo draw a choropleth map showing the geographical distribution of a selected variable by planning subzone, we just need to assign the target variable such as Dependency to tm_polygons().\n\ntm_shape(mpsz_pop2024)+\n  tm_polygons(fill = \"DEPENDENCY\")\n\n\n\n\n\n\n\n\n\n\n3.3.2.2 Drawing a choropleth map using tm_fill() and tm_border()\nActually, tm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the polygon features onto the choropleth map.\nThe code chunk below draws a choropleth map by using tm_fill() alone.\n\ntm_shape(mpsz_pop2024)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\n\n\n\n\nTo add the boundary of the planning subzones, tm_borders() will be used as shown in the code chunk below.\n\ntm_shape(mpsz_pop2024)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders()\n\n\n\n\n\n\n\n\nNotice that light-gray border lines have been added on the choropleth map.\nThe fill_alpha argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).\nBeside fill_alpha argument, there are three other arguments for tm_borders(), they are:\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\ntm_shape(mpsz_pop2024)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(col = \"grey60\",\n             lwd = 0.1,\n             lty = \"dashed\")\n\n\n\n\n\n\n\n\n\n\n\n3.3.3 Data classification methods of tmap\nMost choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\n3.3.3.1 Plotting choropleth maps with built-in classification methods\nThe code chunk below shows a quantile data classification that used 5 classes.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\nIn the code chunk below, equal data classification method is used.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\ntmap_mode(\"plot\")\n\n# Helper to build one choropleth with chosen style + classes\nmake_map &lt;- function(style = \"quantile\", n = 5, title = NULL) {\n  tm_shape(mpsz_pop2024) +\n    tm_polygons(\n      fill = \"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(style = style, n = n, values = \"brewer.blues\"),\n      fill.legend = tm_legend(title = title %||% paste0(\"Style: \", style, \" (n=\", n, \")\"))\n    ) +\n    tm_borders(col = \"grey40\", lwd = 0.3, fill_alpha = 0.5) +\n    tm_layout(frame = TRUE)\n}\n\n# ---------- DIY 1: Compare classification methods ----------\nmap_quantile &lt;- make_map(\"quantile\", 5, \"Quantile (n=5)\")\nmap_equal    &lt;- make_map(\"equal\",    5, \"Equal (n=5)\")\nmap_pretty   &lt;- make_map(\"pretty\",   5, \"Pretty (n=5)\")\nmap_jenks    &lt;- make_map(\"jenks\",    5, \"Jenks (n=5)\")\nmap_kmeans   &lt;- make_map(\"kmeans\",   5, \"K-means (n=5)\")\n\ntmap_arrange(map_quantile, map_equal, map_pretty, map_jenks, map_kmeans, nrow = 2)\n\n\n\n\n\n\n\n# ---------- DIY 2: Same method, different numbers of classes ----------\nq2  &lt;- make_map(\"quantile\", 2,  \"Quantile (n=2)\")\nq6  &lt;- make_map(\"quantile\", 6,  \"Quantile (n=6)\")\nq10 &lt;- make_map(\"quantile\", 10, \"Quantile (n=10)\")\nq20 &lt;- make_map(\"quantile\", 20, \"Quantile (n=20)\")\n\ntmap_arrange(q2, q6, q10, q20, nrow = 2)\n\n\n\n\n\n\n\n\n\nDifferent classification methods change how patterns are revealed:\n\nQuantile shows relative ranking clearly but can split similar values.\n\nEqual bins exaggerate extremes when data are skewed.\n\nJenks and K-means highlight natural clusters more effectively.\n\nThe number of classes affects readability:\n\nFew classes (2–4) oversimplify the data and hide variation.\n\nModerate classes (5–7) balance detail and clarity — best for reporting.\n\nMany classes (10–20) make the map cluttered and hard to interpret.\n\nFor communication and decision-making, Jenks or Quantile with ~5–7 classes gives the clearest insights.\n\n\n\n3.3.3.2 Plotting choropleth map with custome break\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_scale_intervals(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nCode chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2024$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1905  0.7450  0.8377  0.8738  0.9366 12.7500      94 \n\n\nWith reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)\nNow, we will plot the choropleth map by using the code chunk below.\n\ntm_shape(mpsz_pop2024)+\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n3.3.4 Colour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\n3.3.4.1 Using ColourBrewer palette\nTo change the colour, we assign the preferred colour to palette argument of values as shown in the code chunk below.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\nNotice that the choropleth map is shaded in green.\nTo reverse the colour shading, add a “-” prefix.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"-brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n3.3.4.2 Cartographic Furniture\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\nIn the code chunk below, tm_compass(), tm_scale_bar(), tm_grid() and tm_credit() are used to add compass, scale bar, grid lines and data sources onto the choropleth map.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5)) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scalebar() +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: data.gov.sg & singstat\",\n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\n3.3.5 Map Layout\nMap layout refers to the combination of all map elements into a cohensive map. It includes the map background, frame, typography, scale, aspect ratio, margins, and more.\nWe can customize the map layout using the tm_layout() function.\n\n3.3.5.1 Map Legend\nIn tmap, several legend options are provided to change the placement, format and appearance of the legend.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_pos_auto_in() +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scalebar() +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: data.gov.sg & singstat\",\n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n3.3.5.2 Map Style\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().\nThe code chunk below shows the classic style is used.\n\ntm_shape(mpsz_pop2024) +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"-brewer.greens\")) + \n  tm_borders(fill_alpha = 0.5) + \n  tmap_style(\"natural\")\n\n\n\n\n\n\n\n\nTo reset use the code below\n\ntmap_style(\"white\")\n\n\n\n\n\n3.4 Drawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby creating multiple stand-alone maps with tmap_arrange(), and\nby defining a group-by variable in tm_facets().\n\n\n3.4.1 By assigning multiple values to at least one of the aesthetic arguments\nIn this example, small multiple choropleth maps are created by assigning two variables to the visual variable (i.e. fill).\n\ntm_shape(mpsz_pop2024) + \n  tm_polygons(\n    fill = c(\"YOUNG\", \"AGED\"),\n    fill.legend = \n      tm_legend(position = tm_pos_in(\n        \"right\", \"bottom\")),\n    fill.scale = tm_scale_intervals(\n      style = \"equal\", \n      n = 5,\n      values = \"brewer.blues\")) +\n  tm_borders(fill_alpha = 0.5) +\n  tmap_style(\"natural\")\n\n\n\n\n\n\n\n\n\n3.4.1.1 By arrange multiples choropleth maps in a grid layout\nIn this example, multiple choropleth maps are created and tmap_arrnage() is used to arrnage them in a grid layout.\n\nyoungmap &lt;- tm_shape(mpsz_pop2024)+ \n  tm_polygons(fill = \"YOUNG\",\n              fill.legend = tm_legend(\n                position = tm_pos_in(\n                  \"right\", \"bottom\"),\n                  item.height = 0.8),\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\", \n                values = \"brewer.blues\")) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_title(\"Distribution of young population\")\n                \nagedmap &lt;- tm_shape(mpsz_pop2024)+ \n  tm_polygons(fill = \"AGED\",\n              fill.legend = tm_legend(\n                position = tm_pos_in(\n                  \"right\", \"bottom\"),\n                item.height = 0.8),\n              fill.scale = tm_scale_intervals(\n              style = \"quantile\", \n              values = \"brewer.blues\")) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_title(\"Distribution of aged population\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 By defining a group-by variable in tm_facets()\nIn this example, multiple small choropleth maps are created by using tm_facets().\n\ntm_shape(mpsz_pop2024) +\n  tm_fill(fill = \"DEPENDENCY\",\n          fill.scale = tm_scale_intervals(\n            style = \"quantile\",\n            values = \"brewer.blues\")) + \n  tm_facets(by = \"REGION_N\",\n            nrow = 2, \n            ncols = 3,\n            free.coords=TRUE, \n            drop.units=TRUE) +\n  tm_layout(legend.show = TRUE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n3.5 Mappping Spatial Object Meeting a Selection Criterion\nInstead of creating small multiple choropleth map, you can also use filter() of dplyr package to select geographical area of interest and plot a choropleth map focus only on the selected region.\n\nmpsz_pop2024 %&gt;%\n  filter(REGION_N == \"CENTRAL REGION\") %&gt;%\n  tm_shape() +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\", \n                values = \"brewer.greens\"),\n              fill.legend = tm_legend()) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n3.6 Complementing Thematic Map with Statistical Chart\nMaps and statistical charts complement each other by visually representing different aspects of the same data, offering a more comprehensive understanding. Maps excel at showing spatial relationships and geographical patterns, while charts effectively display numerical data, trends, and comparisons. Combining both allows for a more insightful and engaging data narrative, especially when dealing with spatial data that also has quantifiable characteristics.\nWith tmap, statistical chart and be incorporate into the map visualisation by using fill.chat argument of map layers and legend chart feature as shown in the code chunk below.\n\nmpsz_pop2024 %&gt;%\n  filter(REGION_N == \"CENTRAL REGION\") %&gt;%\n  tm_shape() +\n  tm_polygons(fill = \"DEPENDENCY\",\n              fill.scale = tm_scale_intervals(\n                style = \"quantile\", \n                values = \"brewer.greens\"),\n              fill.legend = tm_legend(),\n              fill.chart = tm_chart_box()) +\n  tm_borders() +\n  tm_layout(asp = 0.8)\n\n\n\n\n\n\n\n\nIn the code chunk below, We improve the visual representation further by highlighting and lebaling the outliers on the choropleth map.\n\nmpsz_selected &lt;- mpsz_pop2024 %&gt;%\n  filter(REGION_N == \"CENTRAL REGION\")\n\nstats &lt;- boxplot.stats(mpsz_selected$DEPENDENCY)\n\noutlier_vals &lt;- stats$out\n\noutlier_sf &lt;- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]\n\ntm_shape(mpsz_selected) +\n  tm_polygons(fill = \"DEPENDENCY\",\n          fill.scale = tm_scale_intervals(\n            style = \"quantile\", \n            values = \"brewer.blues\"),\n          fill.legend = tm_legend(),\n          fill.chart = tm_chart_box()) +\n  tm_borders(fill_alpha = 0.5) +\ntm_shape(outlier_sf) +\n  tm_borders(col = \"red\", lwd = 2) +\n  tm_text(\"SUBZONE_N\", col = \"red\", size = 0.7) +\n  tm_layout(asp = 0.8)\n\n\n\n\n\n\n\n\n\n\n3.7 Creating Interactive Maps\nInteractive maps let users actively explore and interact with the data they display. Unlike static maps, you can zoom in and out, pan across areas, click on locations for more information, and even work with data overlays or visualizations—making the experience more dynamic and informative. One of the great things about tmap is that it lets you switch easily between static and interactive maps using tmap_mode(), so you can choose the view that best suits your analysis.\nBy modifying the code chunk in sub-section 3.5, the code chunks below build an interactive map using\n\nregion_selected &lt;- mpsz_pop2024 %&gt;%\n  filter(REGION_N == \"CENTRAL REGION\")\nregion_bbox &lt;- st_bbox(region_selected)\n\nstats &lt;- boxplot.stats(region_selected$DEPENDENCY)\noutlier_vals &lt;- stats$out\noutlier_sf &lt;- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]\n\ntmap_mode(\"view\")\ntm_shape(region_selected, \n         bbox = region_bbox) +\n  tm_fill(\"DEPENDENCY\",\n          id = \"SUBZONE_N\",\n          popup.vars = c(\n            \"Name\" = \"SUBZONE_N\", \n            \"Dependency\" = \"DEPENDENCY\")) +\n  tm_borders() +\n  tm_shape(outlier_sf) +\n  tm_borders(col = \"red\", lwd = 2)\n\n\n\n\n\n\n\ntmap_mode(\"plot\")\n\nThe interactive map above is far from satisfactory. While we want to encourage users to engage and explore the interactive by zooming in and out of the study area freely. But, users might lost in the cyberspace with too much freedom to zoom-in and zoom-out.\nTo address this issue, set_zoom_limits argument can be used to limit the map extend users can zooming in and out of the map areas as shown below.\n\nregion_selected &lt;- mpsz_pop2024 %&gt;%\n  filter(REGION_N == \"CENTRAL REGION\")\nregion_bbox &lt;- st_bbox(region_selected)\n\nstats &lt;- boxplot.stats(region_selected$DEPENDENCY)\noutlier_vals &lt;- stats$out\noutlier_sf &lt;- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]\n\ntmap_mode(\"view\")\n\ntm_shape(region_selected, \n         bbox = region_bbox) +\n  tm_fill(\"DEPENDENCY\",\n          id = \"SUBZONE_N\",\n          popup.vars = c(\n            \"Name\" = \"SUBZONE_N\", \n            \"Dependency\" = \"DEPENDENCY\")) +\n  tm_borders() +\n  tm_shape(outlier_sf) +\n  tm_borders(col = \"red\", lwd = 2) +\n  tm_view(set_zoom_limits = c(12,14))\n\n\n\n\n\ntmap_mode(\"plot\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html",
    "title": "Hands-on Exercise 2",
    "section": "",
    "text": "Spatial Point Pattern Analysis (SPPA) is the evaluation of the pattern or distribution of a set of points on a surface. The points may represent:\n\nEvents such as crimes, traffic accidents, or disease onsets, or\n\nBusiness services (e.g., coffee shops and fast-food outlets) or facilities such as childcare centres and eldercare centres.\n\nFirst-order Spatial Point Pattern Analysis (1st-SPPA) focuses on understanding the intensity or density of points across a study area. It examines how the distribution of points varies over space, essentially identifying trends or patterns in point density. This type of analysis deals with the individual locations of points and their distribution, without considering interactions between them.\nSecond-order spatial point pattern analysis examines the relationships between points, studying whether they are clustered, dispersed, or randomly distributed using tools like Ripley’s K function or nearest-neighbor analysis. It answers the question: “How do points interact with each other in space?”"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#overview",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#overview",
    "title": "Hands-on Exercise 2",
    "section": "",
    "text": "Spatial Point Pattern Analysis (SPPA) is the evaluation of the pattern or distribution of a set of points on a surface. The points may represent:\n\nEvents such as crimes, traffic accidents, or disease onsets, or\n\nBusiness services (e.g., coffee shops and fast-food outlets) or facilities such as childcare centres and eldercare centres.\n\nFirst-order Spatial Point Pattern Analysis (1st-SPPA) focuses on understanding the intensity or density of points across a study area. It examines how the distribution of points varies over space, essentially identifying trends or patterns in point density. This type of analysis deals with the individual locations of points and their distribution, without considering interactions between them.\nSecond-order spatial point pattern analysis examines the relationships between points, studying whether they are clustered, dispersed, or randomly distributed using tools like Ripley’s K function or nearest-neighbor analysis. It answers the question: “How do points interact with each other in space?”"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#first-order-spatial-point-pattern-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#first-order-spatial-point-pattern-analysis",
    "title": "Hands-on Exercise 2",
    "section": "1 First Order Spatial Point Pattern Analysis",
    "text": "1 First Order Spatial Point Pattern Analysis\nIn essence, 1st-SPPA helps answer questions such as:\n\nWhere are points most densely located within the study area?\n\nIs point density uniform, or does it vary across space?\n\nHow spread out is the point pattern?\n\nIn this chapter, we will gain hands-on experience with spatstat to perform two commonly used 1st-SPPA methods.\nThe specific questions we would like to answer are as follows:\n\nAre the childcare centres in Singapore randomly distributed throughout the country?\n\nIf the answer is not, then the next logical question is: where are the locations with higher concentration of childcare centres?\n\n\n1.1 The Data\nChild Care Services data from data.gov.sg, a point feature data providing both location and attribute information of childcare centres. Master Plan 2019 Subzone Boundary (No Sea), a polygon feature data providing information of URA 2019 Master Plan Planning Subzone boundary data.\ngeojson format were used\n\n\n1.2 Installing and Loading the R packages\nIn this hands-on exercise, we will use five R packages:\n\nsf: A modern package designed to import, manage, and process vector-based geospatial data in R.\n\nspatstat: A powerful package for point pattern analysis. We will use it to perform 1st- and 2nd-order spatial point pattern analysis and derive kernel density estimation (KDE) layers.\n\nterra: A fast and efficient package for working with raster and vector data, designed to replace the older raster package. In our exercise, we will use it to convert image outputs generated by spatstat into terra format.\n\ntmap: A package for creating cartographic-quality static maps and interactive maps (via the leaflet API).\n\nrvest: A package for web scraping, which we can use to harvest data directly from web pages.\n\nWe will install and load these packages using the following code:\n\npacman::p_load(sf, terra, spatstat, \n               tmap, rvest, tidyverse)\n\n\n\n1.3 Importing and Wrangling Geospatial Data Sets\n\nsubzone_path   &lt;- \"data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaGEOJSON.geojson\"\nchildcare_path &lt;- \"data/geospatial/ChildCareServices.geojson\"\n\n\n# Read datasets\nmpsz_sf      &lt;- st_read(subzone_path, quiet = TRUE)\nchildcare_sf &lt;- st_read(childcare_path, quiet = TRUE)\n\n# Quick checks\nprint(st_geometry_type(mpsz_sf)[1])\n\n[1] MULTIPOLYGON\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n\nprint(st_geometry_type(childcare_sf)[1])\n\n[1] POINT\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n\n\n\n#Validate geometry\nmpsz_sf      &lt;- st_make_valid(mpsz_sf)\nchildcare_sf &lt;- st_make_valid(childcare_sf)\n\n\n#Transform both datasets to Singapore SVY21 CRS (EPSG:3414)\ntarget_epsg &lt;- 3414\n\nmpsz_sf      &lt;- st_transform(mpsz_sf, target_epsg)\nchildcare_sf &lt;- st_transform(childcare_sf, target_epsg)\n\n\n#Confirm both are aligned\nst_crs(mpsz_sf)$epsg\n\n[1] 3414\n\nst_crs(childcare_sf)$epsg\n\n[1] 3414\n\nidentical(st_crs(mpsz_sf), st_crs(childcare_sf))\n\n[1] TRUE\n\n# Should return TRUE\n\n\n#Optional tidying (only if these fields exist in subzone data)\nif (all(c(\"SUBZONE_N\",\"PLN_AREA_N\") %in% names(mpsz_sf))) {\n  mpsz_sf &lt;- mpsz_sf |&gt;\n    filter(SUBZONE_N != \"SOUTHERN GROUP\",\n           PLN_AREA_N != \"WESTERN ISLANDS\",\n           PLN_AREA_N != \"NORTH-EASTERN ISLANDS\")\n}\n\n\n1.3.1 Mapping the geo spatial data sets\n\n#Quick visual check\ntmap_mode(\"plot\")\ntm_shape(mpsz_sf) + tm_polygons(alpha = 0.2) +\ntm_shape(childcare_sf) + tm_dots(size = 0.03, col = \"red\")\n\n\n\n\n\n\n\n\nInteractive point symbol map\n\ntmap_mode('view')\ntm_shape(childcare_sf)+\n  tm_dots()\n\n\n\n\n\n\ntmap_mode('plot')\n\n\n\n\n1.4 Geospatial Data Wrangling\nspatstat relies on its own specific data structures like ppp (planar point pattern) for point data and owin for observation windows. In this section, we will learn how to convert sf (Simple Features) objects into spatstat ppp and owin object.\n\n1.4.1 Converting sf data frames to ppp class\nThe spatstat package requires point event data in ppp object form.\nWe can use the [as.ppp()] function from spatstat to convert childcare_sf into ppp format. class() of Base R will be used to verify the object class of childcare_ppp.\n\nchildcare_ppp &lt;- as.ppp(childcare_sf)\nclass(childcare_ppp)\n\n[1] \"ppp\"\n\n\nSummary statistics\n\nsummary(childcare_ppp)\n\nMarked planar point pattern:  1925 points\nAverage intensity 2.417322e-06 points per square unit\n\nCoordinates are given to 11 decimal places\n\nMark variables: Name, Description\nSummary:\n     Name           Description       \n Length:1925        Length:1925       \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n\nWindow: rectangle = [11810.03, 45404.25] x [25596.33, 49300.88] units\n                    (33590 x 23700 units)\nWindow area = 796336000 square units\n\n\n\n\n1.4.2 Creating owin object\nWhen analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region. The code chunk below, as.owin() of spatstat is used to covert mpsz_sf into owin object of spatstat.\n\nsg_owin &lt;- as.owin(mpsz_sf)\nclass(sg_owin)\n\n[1] \"owin\"\n\nplot(sg_owin)\n\n\n\n\n\n\n\n\n\n\n1.4.3 Combining point events object and owin object\nIn this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code chunk below.\n\nchildcareSG_ppp = childcare_ppp[sg_owin]\n\n\nchildcareSG_ppp\n\nMarked planar point pattern: 1925 points\nMark variables: Name, Description \nwindow: polygonal boundary\nenclosing rectangle: [2667.54, 56396.44] x [15748.72, 50256.33] units\n\n\n\n\n\n1.5 Clark-Evan Test for Nearest Neighbour Analysis\nNearest Neighbor Analysis (NNA) is a spatial statistics method that calculates the average distance between each point and its closest neighbor to determine if a pattern of points is clustered, dispersed, or randomly distributed.\nClark-Evans test is a specific statistical method used within NNA to quantify whether a point pattern is clustered, random, or uniformly spaced, using the Clark-Evans aggregation index (R) to describe this pattern. NNA provides a numerical value that describes the degree of clustering or regularity, and the Clark-Evans test calculates a specific index (R) for this purpose\nIn this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [clarkevans.test()] from the spatstat.explore package.\nThe test hypotheses are:\n\nH₀: The distribution of childcare services is randomly distributed.\n\nH₁: The distribution of childcare services is not randomly distributed.\n\nWe will use a 95% confidence interval for this test.\n\n1.5.1 Perform the Clark-Evans test without CSR\nclarkevans.test() of spatstat.explore package support two Clark-Evans test, namely: without CRS and with CRS. In the code chunk below, Clark-Evans test without CSR method is used.\n\nclarkevans.test(childcareSG_ppp,\n                correction=\"none\",\n                clipregion=\"sg_owin\",\n                alternative=c(\"clustered\"))\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  childcareSG_ppp\nR = 0.49444, p-value &lt; 2.2e-16\nalternative hypothesis: clustered (R &lt; 1)\n\n\nStatistical Conclusion:\nFrom the Clark-Evans test, the observed R value is 0.53532 with a p-value &lt; 2.2e-16.\nSince the p-value is far below 0.05, we reject the null hypothesis of complete spatial randomness.\nThe result supports the alternative hypothesis that childcare services are clustered rather than randomly distributed.\nBusiness Communication:\nBased on this analysis, we conclude that childcare centres in Singapore tend to be located in clusters.\nThis clustering likely reflects demand-driven planning (e.g., centres opening in areas with higher child populations) or zoning policies.\nFor decision-makers, this indicates that underserved areas may exist where childcare services are sparse, highlighting opportunities for policy adjustments or business expansion into less-served neighborhoods.\n\n\n\n1.6 Kernel Density Estimation Method\nKernel Density Estimation (KDE) is a valuable tool for visualising and analyzing first-order spatial point patterns. It is widely considered a method within Exploratory Spatial Data Analysis (ESDA) because it’s used to visualize and understand spatial data patterns by transforms discrete point data (like locations of childcare service, crime incidents or disease cases) into continuous density surfaces that reveal clusters and variations in event occurrences, without making prior assumptions about data distribution. It helps to begin understanding data distribution, identify hotspots, and explore relationships between spatial variables before performing more rigorous analysis.\nIn this section, you will learn how to compute the kernel density estimation (KDE) of childcare services in Singapore.\n\n1.6.1 Working with automatic bandwidth selection method\nThe code chunk below computes a kernel density by using the following configurations of [density()] from spatstat:\n\nbw.diggle(): automatic bandwidth selection method.\nOther recommended methods are [bw.CvL()], [bw.scott()], or [bw.ppl()].\n\nThe smoothing kernel used is gaussian (default).\nOther smoothing methods include: \"epanechnikov\", \"quartic\", or \"disc\".\n\nThe intensity estimate can be corrected for edge effect bias using the method described by Jones (1993) and Diggle (2010, equation 18.9).\nThe default is FALSE.\n\n\nkde_SG_diggle &lt;- density(\n  childcareSG_ppp,\n  sigma=bw.diggle,\n  edge=TRUE,\n  kernel=\"gaussian\") \nplot(kde_SG_diggle)\n\n\n\n\n\n\n\n#summary(kde_SG_diggle)\n\n\nsummary(kde_SG_diggle)\n\nreal-valued pixel image\n128 x 128 pixel array (ny, nx)\nenclosing rectangle: [2667.537, 56396.44] x [15748.72, 50256.33] units\ndimensions of each pixel: 420 x 269.5907 units\nImage is defined on a subset of the rectangular grid\nSubset area = 784443186.143552 square units\nSubset area fraction = 0.423\nPixel values (inside window):\n    range = [-1.007235e-20, 3.727444e-05]\n    integral = 1927.013\n    mean = 2.456536e-06\n\n\n\nbw &lt;- bw.diggle(childcareSG_ppp)\nbw\n\n   sigma \n295.4419 \n\n\n\n\n1.6.2 Rescalling KDE values\nIn the code chunk below, rescale.ppp() is used to covert the unit of measurement from meter to kilometer.\n\nchildcareSG_ppp_km &lt;- rescale.ppp(\n  childcareSG_ppp, 1000, \"km\")\n\nNow, we can re-run density() using the resale data set and plot the output kde map.\n\nkde_childcareSG_km &lt;- density(childcareSG_ppp_km,\n                              sigma=bw.diggle,\n                              edge=TRUE,\n                              kernel=\"gaussian\")\nplot(kde_childcareSG_km)\n\n\n\n\n\n\n\n\n\n\n1.6.3 Working with different kernel methods\nBy default, the kernel method used in density.ppp() is gaussian. But there are three other options, namely: Epanechnikov, Quartic and Dics.\nThe code chunk below will be used to compute three more kernel density estimations by using these three kernel function.\n\n# Arrange in 2x2 grid with larger maps\npar(mfrow = c(2, 2), mar = c(2, 2, 3, 2))  # adjust margins\n\n# Gaussian\nplot(density(childcareSG_ppp_km,\n             sigma = 0.2959712,\n             edge = TRUE,\n             kernel = \"gaussian\"),\n     main = \"\")\ntitle(\"Gaussian\", line = 1)\n\n# Epanechnikov\nplot(density(childcareSG_ppp_km,\n             sigma = 0.2959712,\n             edge = TRUE,\n             kernel = \"epanechnikov\"),\n     main = \"\")\ntitle(\"Epanechnikov\", line = 1)\n\n# Quartic\nplot(density(childcareSG_ppp_km,\n             sigma = 0.2959712,\n             edge = TRUE,\n             kernel = \"quartic\"),\n     main = \"\")\ntitle(\"Quartic\", line = 1)\n\n# Disc\nplot(density(childcareSG_ppp_km,\n             sigma = 0.2959712,\n             edge = TRUE,\n             kernel = \"disc\"),\n     main = \"\")\ntitle(\"Disc\", line = 1)\n\n\n\n\n\n\n\n\n\n\n\n1.7 Fixed and Adaptive KDE\n\n1.7.1 Computing KDE by using fixed bandwidth\nNext, we will compute a KDE layer by defining a bandwidth of 600 meter. Notice that in the code chunk below, the sigma value used is 0.6. This is because the unit of measurement of childcareSG_ppp_km object is in kilometer, hence the 600m is 0.6km.\n\nkde_childcareSG_fb &lt;- density(childcareSG_ppp_km,\n                              sigma=0.6, \n                              edge=TRUE,\n                              kernel=\"gaussian\")\nplot(kde_childcareSG_fb)\n\n\n\n\n\n\n\n\n\nkde_childcareSG_ab &lt;- adaptive.density(childcareSG_ppp_km,\n                                       sigma = 0.6,\n                                       edge  = TRUE)\npar(mar = c(4, 4, 6, 2))  # more space at top\nplot(kde_childcareSG_ab, main = \"Kernel Density of Childcare Services\")\n\n\n\n\n\n\n\n\nWe can compare the fixed and adaptive kernel density estimation outputs by using the code chunk below.\n\npar(mfrow=c(1,2))\nplot(kde_childcareSG_fb, main = \"Fixed bandwidth\")\nplot(kde_childcareSG_ab, main = \"Adaptive bandwidth\")\n\n\n\n\n\n\n\n\n\n\n1.7.2 Computing KDE by using adaptive bandwidth\nFixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.\n\nkde_childcareSG_ab &lt;- adaptive.density(\n  childcareSG_ppp_km, \n  method=\"kernel\")\nplot(kde_childcareSG_ab)\n\n\n\n\n\n\n\n\n\nlibrary(spatstat.geom)\nsummary(childcareSG_ppp_km)        # look at 'window' units and ranges\n\nMarked planar point pattern:  1925 points\nAverage intensity 2.452904 points per square km\n\nCoordinates are given to 14 decimal places\n\nMark variables: Name, Description\nSummary:\n     Name           Description       \n Length:1925        Length:1925       \n Class :character   Class :character  \n Mode  :character   Mode  :character  \n\nWindow: polygonal boundary\n82 separate polygons (36 holes)\n                  vertices         area relative.area\npolygon 1              285  1.61128e+00      2.05e-03\npolygon 2              719  5.40368e+01      6.89e-02\npolygon 3               44  2.26583e-03      2.89e-06\npolygon 4               27  1.50311e-02      1.92e-05\npolygon 5              708  1.28815e+01      1.64e-02\npolygon 6 (hole)        41 -4.01658e-02     -5.12e-05\npolygon 7 (hole)       316 -5.11288e-02     -6.52e-05\npolygon 8               77  3.29940e-01      4.20e-04\npolygon 9 (hole)         3 -1.31629e-16     -1.68e-19\npolygon 10 (hole)        3 -1.79054e-08     -2.28e-11\npolygon 11              30  2.80002e-02      3.57e-05\npolygon 12 (hole)        4 -2.50786e-07     -3.20e-10\npolygon 13 (hole)        3 -8.52625e-08     -1.09e-10\npolygon 14 (hole)        3 -3.13721e-08     -4.00e-11\npolygon 15 (hole)        3 -5.61019e-08     -7.15e-11\npolygon 16 (hole)        5 -1.43178e-07     -1.82e-10\npolygon 17              71  8.18741e-03      1.04e-05\npolygon 18 (hole)       38 -7.79903e-03     -9.94e-06\npolygon 19 (hole)        3 -3.81487e-09     -4.86e-12\npolygon 20 (hole)        3 -4.87319e-08     -6.21e-11\npolygon 21              91  1.49663e-02      1.91e-05\npolygon 22 (hole)        3 -4.25791e-08     -5.43e-11\npolygon 23 (hole)        4 -3.47312e-08     -4.43e-11\npolygon 24               3  1.96470e-07      2.50e-10\npolygon 25 (hole)      270 -1.21366e-03     -1.55e-06\npolygon 26 (hole)       19 -4.37731e-06     -5.58e-09\npolygon 27 (hole)       35 -1.38430e-04     -1.76e-07\npolygon 28 (hole)       23 -1.99689e-05     -2.54e-08\npolygon 29              40  1.38603e-02      1.77e-05\npolygon 30 (hole)       41 -6.00332e-03     -7.65e-06\npolygon 31 (hole)       11 -8.36614e-05     -1.07e-07\npolygon 32 (hole)        3 -3.69186e-09     -4.70e-12\npolygon 33              45  2.51228e-03      3.20e-06\npolygon 34             137  3.22285e-03      4.11e-06\npolygon 35             147  3.10396e-03      3.96e-06\npolygon 36 (hole)        4 -2.46124e-10     -3.14e-13\npolygon 37              75  1.73525e-02      2.21e-05\npolygon 38              83  5.28926e-03      6.74e-06\npolygon 39             211  4.70522e-01      6.00e-04\npolygon 40             106  3.04131e-03      3.88e-06\npolygon 41             264  1.50631e+00      1.92e-03\npolygon 42              71  5.63055e-03      7.17e-06\npolygon 43              10  1.99759e-04      2.55e-07\npolygon 44 (hole)        3 -2.73199e-08     -3.48e-11\npolygon 45             483  2.06117e+00      2.63e-03\npolygon 46             155  2.67503e-01      3.41e-04\npolygon 47            1020  1.27781e+00      1.63e-03\npolygon 48 (hole)        5 -5.18342e-07     -6.60e-10\npolygon 49 (hole)        4 -7.19058e-07     -9.16e-10\npolygon 50 (hole)        3 -2.53510e-08     -3.23e-11\npolygon 51 (hole)        4 -7.56223e-08     -9.64e-11\npolygon 52 (hole)        4 -1.23063e-10     -1.57e-13\npolygon 53              65  8.42861e-02      1.07e-04\npolygon 54 (hole)        3 -1.06327e-07     -1.35e-10\npolygon 55              47  3.82089e-02      4.87e-05\npolygon 56               6  4.50376e-04      5.74e-07\npolygon 57             129  9.53762e-02      1.22e-04\npolygon 58               4  2.69408e-04      3.43e-07\npolygon 59            1045  4.44510e+00      5.66e-03\npolygon 60              22  6.74620e-03      8.60e-06\npolygon 61              59  3.43163e-02      4.37e-05\npolygon 62              14  5.86528e-03      7.47e-06\npolygon 63              94  5.96175e-02      7.60e-05\npolygon 64             234  2.08755e+00      2.66e-03\npolygon 65              10  4.90997e-04      6.26e-07\npolygon 66             232  4.72887e-01      6.03e-04\npolygon 67 (hole)       13 -3.92141e-04     -5.00e-07\npolygon 68              15  4.03288e-02      5.14e-05\npolygon 69             227  1.10308e+00      1.41e-03\npolygon 70              10  6.60201e-03      8.41e-06\npolygon 71              19  3.09219e-02      3.94e-05\npolygon 72             145  9.61783e-01      1.23e-03\npolygon 73              30  4.28953e-03      5.47e-06\npolygon 74              37  1.29491e-02      1.65e-05\npolygon 75               4  9.47128e-05      1.21e-07\npolygon 76 (hole)        3 -3.50914e-08     -4.47e-11\npolygon 77 (hole)        3 -1.29022e-07     -1.64e-10\npolygon 78 (hole)        4 -4.34886e-07     -5.54e-10\npolygon 79 (hole)        4 -6.40504e-07     -8.16e-10\npolygon 80 (hole)        3 -9.35842e-08     -1.19e-10\npolygon 81           15268  7.00834e+02      8.93e-01\npolygon 82 (hole)        3 -1.80743e-08     -2.30e-11\nenclosing rectangle: [2.66754, 56.39644] x [15.74872, 50.25633] km\n                     (53.73 x 34.51 km)\nWindow area = 784.784 square km\nUnit of length: 1 km\nFraction of frame area: 0.423\n\nunitname(childcareSG_ppp_km)       # should say \"kilometre\"\n\nkm / km \n\n\n\n\n\n1.8 Plotting cartographic quality KDE map\n\n1.8.1 Converting gridded output into raster\nNext, we will convert the im kernal density objects into SpatRaster object by using rast() of terra package.\n\nkde_childcareSG_bw_terra &lt;- rast(kde_childcareSG_km)\nclass(kde_childcareSG_bw_terra)\n\n[1] \"SpatRaster\"\nattr(,\"package\")\n[1] \"terra\"\n\nkde_childcareSG_bw_terra\n\nclass       : SpatRaster \nsize        : 128, 128, 1  (nrow, ncol, nlyr)\nresolution  : 0.4197571, 0.2695907  (x, y)\nextent      : 2.667537, 56.39644, 15.74872, 50.25633  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource(s)   : memory\nname        :         lyr.1 \nmin value   : -1.319098e-14 \nmax value   :  3.727444e+01 \nunit        :            km \n\n\nNotice that the crs property is empty. #### Assigning projection systems In code chunk below, crs() of terra is used to assign the CRS information on kde_childcareSG_bw_terra layer.\n\ncrs(kde_childcareSG_bw_terra) &lt;- \"EPSG:3414\"\nkde_childcareSG_bw_terra\n\nclass       : SpatRaster \nsize        : 128, 128, 1  (nrow, ncol, nlyr)\nresolution  : 0.4197571, 0.2695907  (x, y)\nextent      : 2.667537, 56.39644, 15.74872, 50.25633  (xmin, xmax, ymin, ymax)\ncoord. ref. : SVY21 / Singapore TM (EPSG:3414) \nsource(s)   : memory\nname        :         lyr.1 \nmin value   : -1.319098e-14 \nmax value   :  3.727444e+01 \nunit        :            km \n\n\n\n\n1.8.2 Plotting KDE map with tmap\nFinally, we will display the raster in cartographic quality map using tmap package.\n\ntm_shape(kde_childcareSG_bw_terra) + \n  tm_raster(col.scale = \n              tm_scale_continuous(\n                values = \"viridis\"),\n            col.legend = tm_legend(\n            title = \"Density values\",\n            title.size = 0.7,\n            text.size = 0.7,\n            bg.color = \"white\",\n            bg.alpha = 0.7,\n            position = tm_pos_in(\n              \"right\", \"bottom\"),\n            frame = TRUE)) +\n  tm_graticules(labels.size = 0.7) +\n  tm_compass() +\n  tm_layout(scale = 1.0)\n\n\n\n\n\n\n\n\n\n\n\n1.9 First Order SPPA at the Planning Subzone Level\nIn this section, we would like to further our analysis at the planning area level. For simplicity reason, we will focus on Punggol, Tampines Chua Chu Kand and Jurong West planning areas\n\n1.9.1 Geospatial data wrangling\n\nextract_kml_field &lt;- function(html_text, field_name) {\n  if (is.na(html_text) || html_text == \"\") return(NA_character_)\n  \n  page &lt;- read_html(html_text)\n  rows &lt;- page %&gt;% html_elements(\"tr\")\n  \n  value &lt;- rows %&gt;%\n    keep(~ html_text2(html_element(.x, \"th\")) == field_name) %&gt;%\n    html_element(\"td\") %&gt;%\n    html_text2()\n  \n  if (length(value) == 0) NA_character_ else value\n}\n\n\nlibrary(purrr)\nlibrary(rvest)\n\nmpsz_sf &lt;- mpsz_sf %&gt;%\n  mutate(\n    REGION_N   = map_chr(Description, extract_kml_field, \"REGION_N\"),\n    PLN_AREA_N = map_chr(Description, extract_kml_field, \"PLN_AREA_N\"),\n    SUBZONE_N  = map_chr(Description, extract_kml_field, \"SUBZONE_N\"),\n    SUBZONE_C  = map_chr(Description, extract_kml_field, \"SUBZONE_C\")\n  )\n\n\n1.9.1.1 Extracting study area\n\n# Extract target planning areas\npg &lt;- mpsz_sf %&gt;%\n  filter(PLN_AREA_N == \"PUNGGOL\")\ntm &lt;- mpsz_sf%&gt;%\n  filter(PLN_AREA_N == \"TAMPINES\")\nck &lt;- mpsz_sf %&gt;%\n  filter(PLN_AREA_N == \"CHOA CHU KANG\")\njw &lt;- mpsz_sf %&gt;%\n  filter(PLN_AREA_N == \"JURONG WEST\")\n\nIt is always a good practice to review the extracted areas. The code chunk below will be used to plot the extracted planning areas.\n\npar(mfrow=c(2,2))\nplot(st_geometry(pg), main = \"Ponggol\")\nplot(st_geometry(tm), main = \"Tampines\")\nplot(st_geometry(ck), main = \"Choa Chu Kang\")\nplot(st_geometry(jw), main = \"Jurong West\")\n\n\n\n\n\n\n\n\n\n\n1.9.1.2 Creating owin object\nNow, we will convert these sf objects into owin objects that is required by spatstat.\n\npg_owin = as.owin(pg)\ntm_owin = as.owin(tm)\nck_owin = as.owin(ck)\njw_owin = as.owin(jw)\n\n\n\n1.9.1.3 Combining point events object and owin object\n\nchildcare_pg_ppp = childcare_ppp[pg_owin]\nchildcare_tm_ppp = childcare_ppp[tm_owin]\nchildcare_ck_ppp = childcare_ppp[ck_owin]\nchildcare_jw_ppp = childcare_ppp[jw_owin]\n\nNext, rescale.ppp() function is used to trasnform the unit of measurement from metre to kilometre.\n\nchildcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, \"km\")\nchildcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, \"km\")\nchildcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, \"km\")\nchildcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, \"km\")\n\nThe code chunk below is used to plot these four study areas and the locations of the childcare centres.\n\npar(mfrow=c(2,2))\n\nplot(unmark(childcare_pg_ppp.km), \n     main=\"Punggol\", pch=20, cex=0.6)\n\nplot(unmark(childcare_tm_ppp.km), \n     main=\"Tampines\", pch=20, cex=0.6)\n\nplot(unmark(childcare_ck_ppp.km), \n     main=\"Choa Chu Kang\", pch=20, cex=0.6)\n\nplot(unmark(childcare_jw_ppp.km), \n     main=\"Jurong West\", pch=20, cex=0.6)\n\n\n\n\n\n\n\n\n\n\n\n1.9.2 Clark and Evans Test\n\n1.9.2.1 Choa Chu Kang planning area\nIn the code chunk below, clarkevans.test() of spatstat is used to performs Clark-Evans test of aggregation for childcare centre in Choa Chu Kang planning area.\n\nclarkevans.test(childcare_ck_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  childcare_ck_ppp\nR = 0.84097, p-value = 0.008865\nalternative hypothesis: two-sided\n\n\n\n\n1.9.2.2 Tampines planning area\nIn the code chunk below, the similar test is used to analyse the spatial point patterns of childcare centre in Tampines planning area.\n\nclarkevans.test(childcare_tm_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  childcare_tm_ppp\nR = 0.66817, p-value = 6.579e-12\nalternative hypothesis: two-sided\n\n\n\n\n\n1.9.3 Computing KDE surfaces by planning area\nThe code chunk below will be used to compute the KDE of these four planning area. bw.diggle method is used to derive the bandwidth of each\n\npar(mfrow=c(2,2))\n\n# Punggol\nplot(density(childcare_pg_ppp.km,\n             sigma = bw.diggle(childcare_pg_ppp.km),\n             edge = TRUE, kernel=\"gaussian\"),\n     main = \"Punggol\")\n\n# Tampines\nplot(density(childcare_tm_ppp.km,\n             sigma = bw.diggle(childcare_tm_ppp.km),\n             edge = TRUE, kernel=\"gaussian\"),\n     main = \"Tampines\")\n\n# Choa Chu Kang\nplot(density(childcare_ck_ppp.km,\n             sigma = bw.diggle(childcare_ck_ppp.km),\n             edge = TRUE, kernel=\"gaussian\"),\n     main = \"Choa Chu Kang\")\n\n# Jurong West\nplot(density(childcare_jw_ppp.km,\n             sigma = bw.diggle(childcare_jw_ppp.km),\n             edge = TRUE, kernel=\"gaussian\"),\n     main = \"Jurong West\")"
  }
]